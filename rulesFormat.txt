Правила форматирования SQL
Чем мы руководствовались при подготовке стилей:
·	Простота изучения и поддержки стилей
·	Удобочитаемость кода
·	Скорость разработки
·	Производительность конечного продукта
Ниже даны примеры кода отформатированного по нашим правилам. Код наглядный и дает понимание правил, поэтому сами правила необязательны для чтения и изначально скрыты.
Файлы
·	Название определяется согласно стандарту
·	Кодировка всех файлов UTF-8
Форматирование
Алиасы
 
select 
    s.ID
    ,s.Name
    ,c.CountryName
from sales.Sale as s
    inner join geo.Country as c on c.ID = s.CountryID
    left join finance.Payment as p on p.SaleID = s.ID
where s.Status = 'Completed'
 
Правила представленные в примере
·	Общие правила
○	Алиасы явно с помощью  as  указываются для всех объектов в  select ,  join ,  update … from ,  delete … from ,  merge , а также для CTE, подзапросов  и табличных функций.
○	Алиас пишется на той же строке, что и имя объекта; при вложенных конструкциях указывается сразу после закрывающей скобки.
○	Алиасы не должны создавать путаницу относительно того, к какому объекту они относятся. Наименование алиасов определяется согласно стандарту.
○	При появлении нескольких объектов с похожими названиями использовать более разборчивые алиасы (например,  sd  для  SalesDetail  и  s  для  Sale ).
○	Придерживаться установленных алиасов во всех запросах, чтобы обеспечить предсказуемость и удобство поддержки кода.
·	Применение алиасов в коде
○	Использование в  **join** : Ссылаться на столбцы через алиас присоединяемой таблицы.
○	CTE и подзапросы: При использовании CTE, подзапросов или табличных функций обязательно указывать алиас и обращаться к полям через него.
○	Конструкция  **merge** :
§	Стандартные алиасы: Использовать  t  для целевой таблицы и  s  для источника данных.
§	Единообразие: Придерживаться этих алиасов во всех конструкциях  merge  для предсказуемости и удобства поддержки кода.
 
Пустые строки
 
begin try
    select a.ID, a.Name
    from geo.Area as a

    union all

    select s.ID, s.Name
    from sales.Sale as s
end try
begin catch
    ;throw
end catch

declare
    @OrderID int
    ,@Status varchar(50)

if @OrderID > 0
begin
    set @Status = 'Processed'

    return
end
 
Правила представленные в примере
·	Одной пустой строкой до и после отделяются разные логические блоки кода
 
Отступы
 
declare
    @StartDate date = '2024-01-01'
    ,@EndDate date = '2024-12-31'

if exists (
    select 1
    from sales.Sale as s
    where s.Date between @StartDate and @EndDate
) and (
    select count(*) 
    from geo.Area as a
    where a.Active = 1
) 
begin
    select distinct
        s.ID
        ,a.ID as AreaID
        ,COUNT(p.ID) as PaymentCount
    from sales.Sale as s
        inner join geo.Area as a on a.ID = s.AreaID
        left join finance.Payment as p on p.SaleID = s.ID
    where a.Active = 1
    group by
        s.ID
        ,a.ID
end
else
begin
    insert into sales.Log (Message, LogDate)
    values ('No active sales found', getdate())
end
 
Правила представленные в примере
·	Отступ пишется через  tab 
·	Условия, формулы, выражения и т.п., превышающие длину 120 символов, записываются в несколько строк
○	Каждый параметр записывается с новой строки
○	Содержимое скобок начинается с новой строки, с одним отступом
○	Закрывающая скобка переносится на следующую строку с таким же отступом, как строка, в которой скобка была открыта
·	Все виды  join  пишутся с 1 отступом
·	Логические опреаторы ( and ,  or ) переносятся на следующую строку и выравнивается на 1 отступ от своего «родителя»
·	При наличии нескольких атрибутов, все атрибуты начинаются с новой строки с одним отступом от оператора. Предикаты  distinct ,  top  остаются на уровне с оператором
·	 between  записывается в одну строку, независимо от длины строки
·	 if  и  else  с  begin/end  должны быть на одном уровне
·	Отступов перед  set  нет
·	Вложенные  begin / end  должны выделяться отступами,  begin / end , составляющие один блок, должны размещаться на одном уровне
·	Любое косметическое выравнивание противоречащее вышестоящим пунктам не приветствуется
 
Общие правила использования  exists 
 
/*
    Процедура обновляет статус заказа на основе наличия связанных платежей и доставок.
    Демонстрирует использование конструкции `exists` в следующих контекстах:
    1. В условии `if exists` для проверки существования заказа.
    2. В конструкции `case when exists` для определения нового статуса.
    3. Вложенный `exists` для комплексной проверки внутри условия `case`.
*/
create or alter procedure dbo.UpdateOrderStatus
    @OrderID int
as
begin
    -- Проверяем, существует ли заказ с заданным ID
    if exists (
        select 1
        from dbo.Orders as o
        where o.ID = @OrderID
    )
    and exists (
        select 1
        from dbo.Customers as c
        where c.ID = o.CustomerID
          and c.Status = 'Active'
    )
    begin
        -- Обновляем статус заказа на основе связанных платежей и доставок
        update dbo.Orders
        set Status = (
            case
                when exists (
                    select 1
                    from dbo.Payments as p
                    where p.OrderID = @OrderID
                      and p.Status = 'Pending'
                ) then 'Awaiting Payment'
                when exists (
                    select 1
                    from dbo.Deliveries as d
                    where d.OrderID = @OrderID
                      and d.Status = 'Shipped'
                ) then 'Shipped'
                else
                    case
                        when exists (
                            select 1
                            from dbo.Returns as r
                            where r.OrderID = @OrderID
                              and r.Status = 'Processed'
                        ) then 'Returned'
                        else 'Completed'
                    end
            end
        )
        where ID = @OrderID
    end
end
 
Правила представленные в примере
·	Отступы и выравнивание:
○	Конструкция  exists  должна выравниваться относительно родительского выражения.
○	Содержимое  exists  оформляется с одним отступом.
○	Закрывающая скобка  )  переносится на новую строку и выравнивается с началом  exists .
·	Использование в условиях:
○	При комбинировании с логическими операторами ( and ,  or ),  exists  выносится на новую строку.
○	Если внутри  exists  используется вложенный  exists , соблюдаются те же правила отступов и выравнивания.
 
Правила постановки запятых
 
create or alter procedure dbo.ProcessSales
    @StartDate date
    ,@EndDate date
as
begin
    insert into fact.Sellout (TFM_ID, Shipment, Volume, Value)
    values
        ('1000020021', '2000883532', 10, 100)
        ,('2000883532', '2000572792', 20, 200)
        ,('1000020022', '2000883532', 30, 300)
        ,('1000020023', '2000883532', 40, 400);

    select
        s.ID
        ,s.Name
        ,s.Date
    from sf.Sale as s
    where s.Date between @StartDate and @EndDate
        and exists (
            select 1
            from dbo.Customers as c
            where c.ID = s.CustomerID
        )
end
 
Правила представленные в примере
·	Общие правила:
○	Запятая ставится в начале строки при перечислении элементов, если список переносится на несколько строк.
○	В сложных конструкциях, где запятая разделяет элементы с разным уровнем вложенности, запятая может переноситься на следующую строку вместе с элементом.
·	Специфические случаи:
○	При перечислении атрибутов создаваемой таблицы, запятая ставится в конце строки
○	Перечисление атрибутов в  **SELECT** : Каждый атрибут на новой строке с запятой в начале строки.
○	Перечисление параметров в функциях и процедурах: Каждый параметр на новой строке с запятой в начале строки.
○	В конструкциях  **VALUES** : Запятые разделяют наборы значений, каждый набор на новой строке с запятой в начале.
 
Комментарии
 
/*
    Этот скрипт выполняет обработку заказов, включая:
    1. Обновление статусов заказов.
    2. Удаление устаревших маршрутов.
    3. Расчёт премиальных заказов для клиентов с большой суммой покупок.
    Цель: поддерживать актуальность данных о заказах и маршрутах.
*/
create or alter procedure dbo.ProcessOrdersAndRoutes
as
begin
    -- Обновляем статус заказов для активных клиентов.
    update orders
    set status = 'Completed'
        ,dateupdated = getdate()
    where id in (
        select id
        from customers
        where active = 1
    )

    -- Удаляем устаревшие маршруты, которые больше неактивны.
    delete from routes
    where exists (
        select 1
        from route_statuses
        where route_statuses.route_id = routes.id
          and route_statuses.status = 'Inactive'
    )

    /*
        Рассчитываем премиальные заказы:
        1. Используем подзапрос для суммирования покупок клиентов.
        2. Обновляем статус заказа на "Premium", если общая сумма превышает 5000.
    */
    update o
    set o.status = 'Premium'
    from orders as o
        inner join (
            select customer_id, sum(total_amount) as total_amount
            from order_details
            group by customer_id
            having sum(total_amount) > 5000
        ) as premium_customers on premium_customers.customer_id = o.customer_id;

    -- Логируем изменения в таблицу логов.
    insert into logs (action, description, action_date)
    values ('ProcessOrdersAndRoutes', 'Процесс завершён успешно', getdate())
end
 
Правила представленные в примере
·	Расположение комментариев
○	Комментарий пишется непосредственно над строкой кода.
○	У комментария тот же уровень отступа, что и у строки/блока, к которому он относится.
○	Пустая строка между комментарием и кодом не требуется
·	Ясность и бизнес смысл
○	Комментарии поясняют «зачем» выполняется операция, а не «как».
○	Комментарии для очевидных действий не допускаются (например, — Выбираем все записи из таблицы).
○	Комментарии пишутся грамотно, с соблюдением правил русского языка и точек в конце предложений.
·	Форматы комментариев
○	Однострочные комментарии (—) используются для кратких пояснений.
○	Многострочные комментарии (/* */) используются для развёрнутых пояснений:
§	Открывающая и закрывающая части находятся на отдельных строках.
§	Каждый абзац начинается с новой строки.
·	Поясняющие комментарии для скриптов
○	В начале сложного скрипта добавляйте многострочный комментарий, который объясняет цель всех операций.
○	Такой комментарий обязателен, если:
§	Скрипт содержит несколько логически связанных операций.
§	Используются сложные конструкции (например, вложенные подзапросы или агрегатные функции).
§	Действия скрипта могут быть неочевидны новому разработчику.
 
Пробелы
 
insert into geo.Area(Code, Name)
select
	c.Code
	,c.Name
from geo.Country as c
where c.Code = 'CH'

create table acc.Employee (ID int not null)
alter table acc.Employee add Code varchar(255)

create or alter function bind.udf_GetEmployee(
	@ID_Outlet int
)
returns table
as
return
	select e.Name
	from bind.Employee as e
	where e.ID_Outlet = @ID_Outlet

select uf.*
from rds.udf_UserFlags(1) as uf
 
Правила представленные в примере
·	Пробел нужен после любой синтаксической единицы, если следом за ней нет синтаксических знаков
·	По одному пробелу ставится до и после всех знаков вычисления/сравнения
·	При создании объектов нужен пробел после названия объекта
·	Пробелов не должно быть перед открывающей скобкой при вызове функций
·	Пробелов не должно быть при работе с типами полей. Например:  varchar(255), decimal(10, 2) 
·	Пробелов не должно быть между скобками и их содержимым
·	Пробелов не должно быть в конце строк
·	Пробел не ставится после запятой в начале строки
 
Регистр
 
-- Операторы и системные функции в нижнем регистре
select 
	object_id('sales.Sale') as ObjectID
	,sys.fn_get_audit_file('path', null, null) as AuditFile
from sys.objects
where type = 'U'
 
Правила представленные в примере
·	Ключевые слова, названия системных функций и все операторы пишутся в нижнем регистре
 
Идентификаторы и переменные
 
declare
	@UserID int
	,@UserName varchar(100)

declare @AreaCode varchar(50) = (
	select a.Code 
	from geo.Area as a 
	where a.ID = @UserID
)

select
	s.udf_getNewSaleID(s.ID) as ID_Sale
	,year(s.MDT_DateCreate) as [Year]
from sales.Sale as s
where s.UserID = @UserID
 
Правила представленные в примере
·	Префикс и постфиксы разделяется знаком нижнего подчеркивания  _ 
·	Все идентификаторы, которые потенциально могут быть приняты за ключевое слово, помещаются в квадратные скобки
·	Для объявления переменных  declare  используется один раз. Дополнительное объявление переменных через  declare  используется только, если необходимо использовать ранее объявленную переменную для определения значения объявляемой
 
Типовые конструкции SQL
Создание схем и объектов
 
-- Если схемы не существует в БД, то создаем её
if schema_id('ft') is null
	exec('create schema ft')

-- Проверяем наличие объекта
if object_id('ft.Brand') is null
begin
	create table ft.Brand (
		ID int not null identity,
		Code varchar(255) not null,
		Name varchar(255) null,
		MDT_ID_PrincipalCreatedBy int not null,
		MDT_DateCreate datetime not null,
		constraint PK_Brand primary key clustered (ID)
	)
	alter table ft.Brand add constraint UK_Brand_Code unique (Code)
	alter table ft.Brand add constraint DF_Brand_MDT_ID_PrincipalCreatedBy default mdt.ID_User() for MDT_ID_PrincipalCreatedBy
	alter table ft.Brand add constraint FK_Brand_MDT_ID_PrincipalCreatedBy_Principal foreign key (MDT_ID_PrincipalCreatedBy) references mdt.Principal(ID)
	alter table ft.Brand add constraint DF_Brand_MDT_DateCreate default getdate() for MDT_DateCreate
end
 
 
-- Создаем (если отсутствует в БД) или изменяем триггер
create or alter trigger dbo.tr_Payroll_insert on dbo.Payroll
after insert
as
begin
    update p
    set ID_status_Status = status.ID_Status('dbo.Payroll', 'dbo.Payroll.CALC')
    from dbo.Payroll as p
    where p.ID_status_Status is null
end
 
 
-- Вычисление "Даты начала" и "Даты окончания" месяца, в который входит переданная "Дата"
create or alter function dbo.udf_GetMonthPeriodDates(
   -- Все параметры, принимаемые функцией или процедурой перечисляются с новой строки
   @Date date
)
returns table
as
return 
   select
      cast(dateadd(month, datediff(month, 0, @Date),0) as date) as DateBegin
      ,eomonth(@Date) as DateEnd
 
Правила представленные в примере
·	Для того, чтобы повторное выполнение скрипта не приводило к возникновению ошибки, необходимо проверять существование в БД создаваемого объекта
·	Обязательность атрибута указывается сразу после типа данных
·	Во всех созданных таблицах, кроме  SA  таблиц, обязательно наличие системных полей:  MDT_DateCreate ,  MDT_ID_PrincipalCreatedBy 
·	 null / not null  указывается явно для всех атрибутов
·	 alter table  записывается в одну строку, независимо от длины строки
·	При создании объектов через интерфейс  MDT  и последующем переносе скрипта в репозиторий, необходимо убедиться, что соблюдены правила форматирования SQL
·	Каждый из параметров, принимаемых процедурой или функцией указывается с новой строки с одним отступом, независимо от их количества
 
Обновление и удаление данных в таблицах
 
-- Простой запрос на обновление
update Orders
set 
	Status = 'Completed'
	,DateUpdated = getdate()
where ID = 100

-- Сложный запрос на обновление
update o
set
	o.Status = 'Completed'
	,o.DateUpdated = getdate()
from Orders as o
	inner join Customers as c on c.ID = o.CustomerID
where c.Region = 'North'
	and c.Status = 'Active'

-- Пример с удалением записей
delete r
from dim.Route as r
where r.FlagActive <> cast(1 as bit)
 
Правила представленные в примере
·	При написании  update  и  delete  запросов используется конструкция с  from  для указания таблицы-источника.
·	Каждое поле в  set  записывается с новой строки.
·	Логические операторы ( and ,  or ) в условиях  where  всегда переносятся на новую строку с отступом для повышения читаемости.
 
Соединение таблиц с помощью JOIN
 
select
	o.PartYearMonth
	,d.Date
	,ph.ID_SKU
	,o.Volume
	,o.Value
from fact.SOP_Offtake as o
	inner join dim.ProductHierarchy as ph on ph.ID = o.ID_ProductHierarchy
    left join dim.Date as d on d.ID = o.ID_Date
where ph.FlagExcludeSegment = cast(0 as bit)
    and ph.ProductBrandFlagConcurrent = cast(0 as bit)
 
Правила представленные в примере
·	Все виды  join  указываются явно
·	Лучшей практикой является использование  inner join  и  left join , вместо  right  и  full  join
·	При соединении таблиц сперва после  on  указываем поле присоединяемой таблицы
 
Конструкция CASE
 
select 
	o.ID
	,case
		when o.Status = 'Pending' then 'In Progress'
		when o.Status = 'Completed' and o.LastUpdate > '2023-01-01' then 'Recently Updated'
		when exists (
			select 1
			from dbo.Customers as c
			where c.ID = o.CustomerID
				and (
					exists (
						select 1
						from dbo.Feedback as f
						where f.CustomerID = c.ID
							and f.Rating > 4
					)
					or exists (
						select 1
						from dbo.Orders as sub_o
						where sub_o.CustomerID = c.ID
							and sub_o.Status = 'Completed'
					)
				)
		) then 'Has Active Engagement'
		else 'No Data'
	end as OrderStatusSummary
from dbo.Orders as o
	inner join dbo.Customers as c on c.ID = o.CustomerID
		left join (
			select 
				p.ProductID
				,case
					when p.Quantity > 10 then 'High Quantity'
					when p.Quantity between 5 and 10 then 'Medium Quantity'
					else 'Low Quantity'
				end as QuantityLevel
			from dbo.Products as p
		) as p on p.ProductID = o.ProductID
where case
		when o.Status = 'Pending' then 1
		when o.Status = 'Completed' and o.TotalAmount > 1000 then 2
		else 0
	end > 0
 
Правила представленные в примере
·	Конструкция case выравнивается относительно своего контекста ( select ,  join  и т.д.).
·	Каждое условие when записывается на новой строке с 1 отступом.
·	 Then  всегда остаётся на одной строке с  when .
·	Конструкция end выравнивается на том же уровне, что и  case .
·	Содержимое  case  ( when ,  then ,  else ) должно быть выровнено на 1 отступ относительно  case .
·	Логические операторы ( and ,  or ) внутри  when  записываются на новых строках с тем же уровнем отступа.
 
Конструкция IF
 
-- Пример 1: Одно действие без begin/end
if col_length('rds.Shipment', 'Round') is not null
	alter table rds.Shipment alter column Round varchar(4000)

-- Пример 2: Условие с логическим оператором and, выполняется одно действие
if status = 'Pending'
	and region = 'North'
	update orders
	set status = 'Approved'
	where status = 'Pending'

-- Пример 3: Используем exists и выполняем одно действие
if exists (
		select ID
		from dbo.Customers as c
		where c.Active = 1
	)
	delete from dbo.TempCustomers
	where Processed = 0

-- Пример 4: Используем exists с несколькими действиями
if exists (
		select ID
		from dbo.Orders as o
		where o.Status = 'Pending'
	)
	and exists (
		select 1
		from dbo.Customers as c
		where c.Active = 1
	)
begin
	-- Обновляем статус заказов на "Approved".
	update dbo.Orders
	set status = 'Approved'
	where status = 'Pending'

	-- Логируем операцию в таблицу system_log.
	insert into dbo.SystemLog (Module, Description, DateCreated)
	values ('OrderProcessing', 'Pending orders updated', getdate())
end
 
Правила представленные в примере
·	Если конструкция  iif  не умещается в одну строку, аргументы записываются с новой строки с одним отступом от `iif
·	Если внутри условия выполняется только одно действие,  begin/end  не требуется. Инструкция записывается на новой строке с 1 отступом.
·	Если внутри условия выполняется более одного действия, используйте  begin/end 
 
Конструкция CTE
 
;with cte_RecentSales as (
	select
		s.ID
		,s.Date
		,s.Amount
	from dbo.Sales as s
	where s.Date > '2024-01-01'
)
select 
	rs.ID
	,rs.Date
	,rs.Amount
from cte_RecentSales as rs
where rs.Amount > 1000
 
Правила представленные в примере
·	При необходимости,  ;  ставится перед  with  без пробелов.
·	При именовании табличного выражения ( cte ), используется маска  cte_{Название} .
○	Название  cte  должно быть осмысленным и записывается с использованием  PascalCase .
·	После  cte  пустая строка не ставится.
 
Конструкция MERGE
 
merge tpm.DistributorBonusForReview as t
using (
	select
		fdb.ID_md_CompanyDistributor
		,fdb.ID_md_CompanyShipment
		,fdb.ID_ref_EmployeeResponsible
		,fdb.ID_Review
	from cte_FixDistributorBonus as fdb
) as s on s.ID_Review = t.ID_Review
		and s.ID_md_CompanyDistributor = t.ID_md_Company
when matched then
	update
	set
		ID_md_Company = s.ID_md_CompanyDistributor
		,ID_md_CompanyShipment = s.ID_md_CompanyShipment
when not matched then
	insert (ID_md_Company, ID_md_CompanyShipment, ID_Review)
	values (s.ID_md_CompanyDistributor, s.ID_md_CompanyShipment, s.ID_Review)
when not matched by source and s.ID_calendar_Month < @ID_Month then
	update
	set ID_ref_FixPaymentType = @ID_OldType;
 
Правила представленные в примере
·	Перед названием таблицы, в которую осуществляется  merge ,  into  не указывается
·	 when  с таким же отступом, как  merge 
·	 then  записывается на одной строке с  when , независимо от наличия дополнительных условий
·	 ;  ставится в конце последней строки конструкции  merge 
 
Конструкция VALUES
 
select
    c.ID as ID_md_CompanyClient
    ,isnull(cs.ID_mapping_MDT, cs.ID) as ID_CompanyShipment
    ,e.ID as ID_ref_Employee
    ,r.ID as ID_Review
    ,s.ValueForJanuary
    ,s.ValueForFebruary
    ,s.ValueForMarch
    ,s.ValueForApril
    ,s.ValueForMay
    ,s.ValueForJune
    ,s.ValueForJuly
    ,s.ValueForAugust
    ,s.ValueForSeptember
from (
    values
        ('1000020021', '2000883532', 0, 0, 0, 0, 0, 0, 0, 0, 0)
        ,('2000883532', '2000572792', 0, 0, 0, 0, 0, 0, 0, 0, 0)
        ,('1000020022', '2000883532', 0, 0, 0, 0, 0, 0, 0, 0, 0)
        ,('1000020023', '2000883532', 0, 0, 0, 0, 0, 0, 0, 0, 0)
) as s (TFM_ID, Shipment, ValueForJanuary, ValueForFebruary, ValueForMarch, ValueForApril, ValueForMay, ValueForJune, ValueForJuly, ValueForAugust, ValueForSeptember)
    inner join md.Company_AdditionalInfo as cai on cai.TFM_ID = s.TFM_ID
    inner join md.Company as c on c.ID = cai.ID_Company
    inner join md.Company as c_shipm on c_shipm.Code = s.Shipment
    inner join mapping.DataSource as ds on ds.ID = c.ID_mapping_DataSource
        and ds.Code = 'MDT'
    inner join ref.Employee as e on e.ID = cai.ID_ref_EmployeeResponsible
    inner join tpm.Review as r on r.ID_calendar_Period = 20221
    left join fact.SellOut as so on so.ID_md_Company = c.ID
where so.ID_md_Company is null

insert into fact.Sellout (TFM_ID, Shipment, Volume, Value)
values
    ('1000020021', '2000883532', 10, 100)
    ,('2000883532', '2000572792', 20, 200)
    ,('1000020022', '2000883532', 30, 300)
    ,('1000020023', '2000883532', 40, 400)
 
Заполнение объектов
 
-- Конструкция merge
merge spec.Service as t
using (
    select
        s.Code
        ,s.Name
        ,st.ID as ID_ServiceType
        ,u.ID as ID_Unit
    from (
        values
            ('Support', 'Service', 'Услуга по поддержке (шт)', 'шт')
            ,('Develop', 'Service', 'Услуга по разработке (чел/час)', 'чел/час')
            ,('Data processing', 'Service', 'Услуга по обработке данных (чел/час)', 'чел/час')
            ,('License', 'License', 'Лицензия (шт)', 'шт')
            ,('Develop in pieces', 'Service', 'Услуга по разработке (шт)', 'шт')
    ) as s (Code, ServiceTypeCode, Name, UnitName)
        inner join spec.Unit as u (nolock) on u.Name = s.UnitName
        inner join spec.ServiceType as st (nolock) on st.Code = s.ServiceTypeCode
) as s on s.Code = t.Code
when matched then
    -- Если такая запись уже существует - обновляем данные
    update
    set
        Name = s.Name
        ,ID_ServiceType = s.ID_ServiceType
        ,ID_Unit = s.ID_Unit
when not matched then
    -- Если такой записи не существует в объекте - добавляем её
    insert (Code, Name, ID_ServiceType, ID_Unit)
    values (s.Code, s.Name, s.ID_ServiceType, s.ID_Unit);

-- Конструкция insert
insert into yt.Priority (ID, Code, Name, BgColor, FgColor, SortOrder, Weight)
select
    s.ID
    ,s.Code
    ,s.Name
    ,s.BgColor
    ,s.FgColor
    ,s.SortOrder
    ,s.Weight
from (
    values (-1, 'Unknown', 'Unknown', '#ffffff', '#000000', 7, 0)
) as s (ID, Code, Name, BgColor, FgColor, SortOrder, Weight)
    -- Присоединяем таблицу, в которую вносим данные
    left join yt.Priority as p on p.Code = s.Code
-- Проверяем, что такой записи еще нет в таблице
where p.ID is null
 
Правила представленные в примере
·	При заполнении объектов данными, проверяем существование такой записи по уникальному ключу
·	Если необходимо выполнить разные инструкции в зависимости от условий, используем конструкцию  merge :
○	Например, обновить значения в атрибутах, если запись с таким уникальным набором значений уже существует или добавить новую в противном случае
·	Если необходимо только добавлять новые записи, игнорируя существующие, используем конструкции  insert ,  select 
○	С помощью  left join  проверяем наличие записи в объекте по уникальному ключу
 
Лучшие практики
·	Рекомендуется вместо подзапроса использовать CTE (Common Table Expression), временную таблицу или табличную переменную
·	Рекомендуется создавать  identity ID  поля только для следующих таблиц:
○	Для справочников —  int 
○	Для небольших справочников —  tinyint 
·	Рекомендуется в случае необходимости создавать фиктивную партицию в таблицах фактов со значением  190001 
·	Рекомендуется при объявлении типов не использовать длину поля  max 
○	Пример:
§	 varchar(8000) 
§	 nvarchar(4000) 
·	Рекомендуется избегать неявных преобразований в типах данных
○	Пример:
 
select
    ps.ID as ID_ProductSKU
    ,ps.ID_Brand
from dbo.D_ProductSKU as ps
-- Преобразуем значение в bit, так как `1` значение типа int
where ps.FlagConcurrentBrand = cast(1 as bit)
    -- Преобразуем значение в `int`, так как UID_DS `varchar`
    and try_cast(ps.UID_DS as int) = 101121
 
·	Рекомендуется писать проверки только для DDL инструкций
○	Пример:
 
if col_length('rds.Shipment', 'Round') is not null
    alter table rds.Shipment alter column Round varchar(4000)
 
Оптимизация
·	Повторяющийся код должен быть вынесен в отдельную структуру для повторного использования
·	Стараться избегать применения  cross apply ,  outer apply 
·	Стараться избегать применения  cursor , по возможности применять вместо него  while 
